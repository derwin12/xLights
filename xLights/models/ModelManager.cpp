/***************************************************************
 * This source files comes from the xLights project
 * https://www.xlights.org
 * https://github.com/xLightsSequencer/xLights
 * See the github commit history for a record of contributing
 * developers.
 * Copyright claimed based on commit dates recorded in Github
 * License: https://github.com/xLightsSequencer/xLights/blob/master/License.txt
 **************************************************************/

#include <cmath>

#include <wx/msgdlg.h>
#include <wx/stdpaths.h>
#include <wx/xml/xml.h>

#include "ArchesModel.h"
#include "BaseObject.h"
#include "CandyCaneModel.h"
#include "ChannelBlockModel.h"
#include "CheckboxSelectDialog.h"
#include "CircleModel.h"
#include "CubeModel.h"
#include "CustomModel.h"
#include "ExternalHooks.h"
#include "IciclesModel.h"
#include "ImageModel.h"
#include "Model.h"
#include "ModelGroup.h"
#include "ModelManager.h"
#include "MultiPointModel.h"
#include "OutputModelManager.h"
#include "Parallel.h"
#include "PolyLineModel.h"
#include "SingleLineModel.h"
#include "SphereModel.h"
#include "SpinnerModel.h"
#include "StarModel.h"
#include "SubModel.h"
#include "TreeModel.h"
#include "UtilFunctions.h"
#include "WindowFrameModel.h"
#include "WreathModel.h"
#include "XmlSerializer/XmlSerializer.h"
#include "XmlSerializer/XmlDeserializingModelFactory.h"
#include "../ModelPreview.h"
#include "../Pixels.h"
#include "../controllers/ControllerCaps.h"
#include "../sequencer/Element.h"
#include "../xLightsMain.h"
#include "DMX/DmxFloodArea.h"
#include "DMX/DmxFloodlight.h"
#include "DMX/DmxGeneral.h"
#include "DMX/DmxMovingHead.h"
#include "DMX/DmxMovingHeadAdv.h"
#include "DMX/DmxServo.h"
#include "DMX/DmxServo3D.h"
#include "DMX/DmxSkull.h"
#include "outputs/Controller.h"
#include "outputs/ControllerEthernet.h"
#include "outputs/Output.h"
#include <log4cpp/Category.hh>

ModelManager::ModelManager(OutputManager* outputManager, xLightsFrame* xl) :
    _outputManager(outputManager),
    xlights(xl),
    layoutsNode(nullptr),
    previewWidth(0),
    previewHeight(0),
    _modelsLoading(false)
{
    // ctor
}

ModelManager::~ModelManager()
{
    // Because loading models is async we have to ensure this is done before we destroy anything
    while (_modelsLoading)
        wxMilliSleep(1);

    clear();
}

void ModelManager::clear()
{
    std::lock_guard<std::recursive_mutex> _lock(_modelMutex);
    for (auto& it : models) {
        if (it.second != nullptr) {
            delete it.second;
            it.second = nullptr;
        }
    }
    models.clear();
}

inline BaseObject* ModelManager::GetObject(const std::string& name) const
{
    return GetModel(name);
}

bool ModelManager::IsModelValid(const Model* m) const
{
    // we do this because it is a BaseObject recast as a Model so it clearly isn't a model and so we assume it is valid
    if (m == nullptr)
        return true;

    std::lock_guard<std::recursive_mutex> lock(_modelMutex);
    for (const auto& it : models) {
        if (it.second == m)
            return true;

        for (auto it2 : it.second->GetSubModels()) {
            if (it2 == m)
                return true;
        }
    }
    return false;
}

Model* ModelManager::GetModel(const std::string& name) const
{
    std::unique_lock<std::recursive_mutex> lock(_modelMutex);
    auto it = models.find(Trim(name));
    lock.unlock();

    if (it == models.end()) {
        size_t pos = name.find("/");
        if (pos != std::string::npos) {
            std::string mname = Trim(name.substr(0, pos));
            std::string smname = Trim(name.substr(pos + 1));
            Model* m = GetModel(mname);
            if (m != nullptr) {
                return m->GetSubModel(smname);
            }
        }
        return nullptr;
    }
    return it->second;
}

Model* ModelManager::operator[](const std::string& name) const
{
    return GetModel(Trim(name));
}

bool ModelManager::Rename(const std::string& oldName, const std::string& newName)
{
    auto on = Trim(oldName);
    auto nn = Trim(newName);
    Model* model = GetModel(on);
    if (model == nullptr || model->GetDisplayAs() == "SubModel") {
        return false;
    }
    model->Rename(nn);
    model->name = nn;
    if (dynamic_cast<SubModel*>(model) == nullptr) {
        std::lock_guard<std::recursive_mutex> lock(_modelMutex);
        bool changed = false;
        for (auto& it2 : models) {
            changed |= it2.second->ModelRenamed(on, nn);
        }
        models.erase(models.find(on));
        models[nn] = model;

        // go through all the model groups looking for things that might need to be renamed
        for (const auto& it : models) {
            ModelGroup* mg = dynamic_cast<ModelGroup*>(it.second);
            if (mg != nullptr) {
                changed |= mg->ModelRenamed(on, nn);
            }
        }

        return changed;
    }

    return false;
}

bool ModelManager::RenameSubModel(const std::string& oldName, const std::string& newName)
{
    bool changed = false;

    auto on = Trim(oldName);
    auto nn = Trim(newName);

    for (auto& m : *this) {
        if (m.second->GetDisplayAs() == "ModelGroup") {
            ModelGroup* mg = dynamic_cast<ModelGroup*>(m.second);
            changed |= mg->SubModelRenamed(on, nn);
        }
    }

    return changed;
}

bool ModelManager::RenameInListOnly(const std::string& oldName, const std::string& newName)
{
    auto on = Trim(oldName);
    auto nn = Trim(newName);

    Model* model = GetModel(on);
    if (model == nullptr)
        return false;

    std::lock_guard<std::recursive_mutex> lock(_modelMutex);
    models.erase(models.find(on));
    models[nn] = model;
    return true;
}

bool ModelManager::IsModelOverlapping(const Model* model) const
{
    int32_t start = model->GetFirstChannel(); // model->GetNumberFromChannelString(model->ModelStartChannel);
    int32_t end = start + model->GetChanCount() - 1;
    // int32_t sstart = model->GetFirstChannel() + 1;
    // wxASSERT(sstart == start);
    // int32_t send = model->GetLastChannel() + 1;
    // wxASSERT(send == end);
    for (const auto& it : *this) {
        if (it.second->GetDisplayAs() != "ModelGroup" && it.second->GetName() != model->GetName()) {
            int32_t s = it.second->GetFirstChannel(); // GetNumberFromChannelString(it->second->ModelStartChannel);
            int32_t e = s + it.second->GetChanCount() - 1;
            // int32_t ss = it->second->GetFirstChannel() + 1;
            // wxASSERT(ss == s);
            // int32_t se = it->second->GetLastChannel() + 1;
            // wxASSERT(se == e);
            if (start <= e && end >= s)
                return true;
        }
    }
    return false;
}

void ModelManager::LoadModels(wxXmlNode* modelNode, int previewW, int previewH)
{
    static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
    // logger_base.debug("ModelManager loading models.");

    _modelsLoading = true;
    clear();
    previewWidth = previewW;
    previewHeight = previewH;
    this->modelNode = modelNode;
    wxStopWatch timer;
    std::list<wxXmlNode*> modelsToLoad;
    for (wxXmlNode* e = modelNode->GetChildren(); e != nullptr; e = e->GetNext()) {
        if (e->GetName() == "model") {
            std::string name = e->GetAttribute("name").Trim(true).Trim(false).ToStdString();
            if (!name.empty()) {
                modelsToLoad.push_back(e);
            }
        }
    }
    std::function<void(wxXmlNode*&, int)> f = [this, previewW, previewH](wxXmlNode* e, int idx) {
        createAndAddModel(e, previewW, previewH);
    };
    RunInAutoReleasePool([&]() {parallel_for(modelsToLoad, f);});
    // printf("%d Models loaded in %ldms", (int)modelsToLoad.size(), timer.Time());
    logger_base.debug("Models loaded in %ldms", timer.Time());
    _modelsLoading = false;

    // Check all recorded shadow models actually exist
    for (auto& it : models) {
        if (it.second->GetShadowModelFor() != "") {
            auto m = models.find(it.second->GetShadowModelFor());
            if (m == models.end()) {
                // showing model does not exist
                it.second->SetShadowModelFor("");
            }
        }
    }

    xlights->GetOutputModelManager()->AddASAPWork(OutputModelManager::WORK_CALCULATE_START_CHANNELS, "ModelManager::LoadModels");
    // RecalcStartChannels();
}

uint32_t ModelManager::GetLastChannel() const
{
    std::lock_guard<std::recursive_mutex> lock(_modelMutex);
    unsigned int max = 0;
    for (const auto& it : models) {
        max = std::max(max, it.second->GetLastChannel());
    }
    return max;
}

void ModelManager::ResetModelGroups() const
{
    // static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
    // logger_base.debug("ModelManager resetting groups.");

    // This goes through all the model groups which hold model pointers and ensure their model pointers are correct
    std::lock_guard<std::recursive_mutex> lock(_modelMutex);
    for (const auto& it : models) {
        if (it.second != nullptr && it.second->GetDisplayAs() == "ModelGroup") {
            ((ModelGroup*)(it.second))->ResetModels();
        }
    }
    for (const auto& it : models) {
        if (it.second != nullptr && it.second->GetDisplayAs() == "ModelGroup") {
            ((ModelGroup*)(it.second))->CheckForChanges();
        }
    }
}

std::string ModelManager::GetLastModelOnPort(const std::string& controllerName, int port, const std::string& excludeModel, const std::string& protocol) const
{
    std::string last = "";
    unsigned int highestEndChannel = 0;
    std::lock_guard<std::recursive_mutex> lock(_modelMutex);

    for (const auto& it : models) {
        if (it.second->GetDisplayAs() != "ModelGroup" &&
            it.second->GetControllerName() == controllerName &&
            it.second->GetControllerPort() == port &&
            it.second->GetControllerProtocol() == protocol &&
            it.second->GetLastChannel() > highestEndChannel && it.first != excludeModel) {
            last = it.first;
            highestEndChannel = it.second->GetLastChannel();
        }
    }
    return last;
}

std::string ModelManager::GetLastModelOnPort(const std::string& controllerName, int port, const std::string& excludeModel, const std::string& protocol, int smartReceiver) const
{
    std::string last = "";
    unsigned int highestEndChannel = 0;
    std::lock_guard<std::recursive_mutex> lock(_modelMutex);

    for (const auto& it : models) {
        if (it.second->GetDisplayAs() != "ModelGroup" &&
            it.second->GetControllerName() == controllerName &&
            it.second->GetControllerPort() == port &&
            it.second->GetControllerProtocol() == protocol &&
            it.second->GetSmartRemote() == smartReceiver &&
            it.second->GetLastChannel() > highestEndChannel && it.first != excludeModel) {
            last = it.first;
            highestEndChannel = it.second->GetLastChannel();
        }
    }
    return last;
}

void ModelManager::ReplaceIPInStartChannels(const std::string& oldIP, const std::string& newIP)
{
    std::lock_guard<std::recursive_mutex> lock(_modelMutex);
    for (const auto& it : models) {
        if (it.second->GetDisplayAs() != "ModelGroup") {
            if (Contains(it.second->ModelStartChannel, oldIP)) {
                it.second->ReplaceIPInStartChannels(oldIP, newIP);
            }
        }
    }
}

void ModelManager::AddModelGroups(wxXmlNode* n, int w, int h, const std::string& mname, bool& merge, bool& ask) {
    // static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
    // logger_base.debug("ModelManager adding groups.");

    auto grpModels = n->GetAttribute("models");
    if (grpModels.empty())
    {
        return;
    }

    auto mgname = n->GetAttribute("name");
    bool alias { false };
    if (models.find(mgname) != models.end()) {
        for (const auto& [name, mm] : models) {
            if (mm->GetDisplayAs() == "ModelGroup") {
                if (mm->IsAlias(mgname, false)) {
                    mgname = name;
                    alias = true;
                    break;
                }
            }
        }
    }

    if (models.find(mgname) != models.end()) {
        if (ask && !alias) {
            wxMessageDialog confirm(GetXLightsFrame(), _("Model contains Model Group(s) that Already Exist.\n Would you Like to Add this Model to the Existing Groups?"), _("Model Group(s) Already Exists"), wxYES_NO);
            int returnCode = confirm.ShowModal();
            if (returnCode == wxID_YES)
                merge = true;
            ask = false;
        }
        if (merge || alias) { // merge
            Model* mg = GetModel(mgname);
            if (mg->GetDisplayAs() == "ModelGroup") {
                ModelGroup* mmg = dynamic_cast<ModelGroup*>(mg);
                bool found = false;
                std::vector<wxString> prevousNames;
                auto oldModelNames = mmg->ModelNames(); // we copy the name list as we are going to be modifying the group while we iterate over these
                for (const auto& it : oldModelNames) {
                    auto mmnmn = mmg->ModelNames();
                    if (Contains(it, "/")) { // only add new SubModel if the name matches an old SubModel name, I don't understand why?
                        auto mgmn = wxString(it);
                        mgmn = mname + "/" + mgmn.AfterFirst('/');
                        std::string em = "EXPORTEDMODEL/" + mgmn.AfterFirst('/');
                        if (ContainsBetweenCommas(grpModels, em)) {
                            if (std::find(mmnmn.begin(), mmnmn.end(), mgmn.ToStdString()) == mmnmn.end() &&
                                std::find(prevousNames.begin(), prevousNames.end(), mgmn) == prevousNames.end() &&
                                !mmg->DirectlyContainsModel(mgmn)) {
                                mmg->AddModel(mgmn);
                                prevousNames.push_back(mgmn);
                                found = true;
                            }
                        } else { // look for zero padded
                            std::string submodel = it.substr(it.find('/') + 1);
                            size_t pos = submodel.find_last_of(' ');
                            std::string num_str;
                            if (pos != std::string::npos) {
                                std::string before_space = submodel.substr(0, pos);
                                size_t num_start = before_space.find_last_of(' ') + 1;
                                if (num_start == 0 || num_start >= before_space.length()) num_start = 0;
                                size_t i = num_start;
                                while (i < before_space.length() && std::isdigit(before_space[i])) {
                                    num_str += before_space[i];
                                    ++i;
                                }
                            }
                            if (num_str.empty()) {
                                size_t i = 0;
                                while (i < submodel.length() && std::isdigit(submodel[i])) {
                                    num_str += submodel[i];
                                    ++i;
                                }
                            }
                            if (!num_str.empty()) {
                                try {
                                    int num = std::stoi(num_str);
                                    std::string itZeroPad;
                                    if (pos != std::string::npos) {
                                        size_t num_start = submodel.find_last_of(' ', pos - 1) + 1;
                                        if (num_start >= submodel.length()) num_start = 0;
                                        itZeroPad = it.substr(0, it.find('/') + 1) + submodel.substr(0, num_start) +
                                            (num < 10 ? "0" : "") + std::to_string(num);
                                        size_t num_end = num_start + num_str.length();
                                        if (num_end < submodel.length()) {
                                            itZeroPad += submodel.substr(num_end);
                                        }
                                    } else {
                                        itZeroPad = it.substr(0, it.find('/') + 1) +
                                            (num < 10 ? "0" : "") + std::to_string(num);
                                    }
                                    auto mgmn = wxString(itZeroPad);
                                    mgmn = mname + "/" + mgmn.AfterFirst('/');
                                    std::string em = "EXPORTEDMODEL/" + mgmn.AfterFirst('/');
                                    if (ContainsBetweenCommas(grpModels, em) &&
                                        std::find(mmnmn.begin(), mmnmn.end(), mgmn.ToStdString()) == mmnmn.end() &&
                                        std::find(prevousNames.begin(), prevousNames.end(), mgmn) == prevousNames.end() &&
                                        !mmg->DirectlyContainsModel(mgmn)) {
                                        mmg->AddModel(mgmn);
                                        prevousNames.push_back(mgmn);
                                        found = true;
                                    }
                                } catch (const std::exception&) {
                                }
                            }
                        }
                    } else {
                        if (ContainsBetweenCommas(grpModels, it) && std::find(mmnmn.begin(), mmnmn.end(), mname) == mmnmn.end() &&
                            std::find(prevousNames.begin(), prevousNames.end(), mname) == prevousNames.end() &&
                            !mmg->DirectlyContainsModel(mname)) {
                            mmg->AddModel(mname);
                            prevousNames.push_back(mname);
                            found = true;
                        }
                    }
                }

                if (!found) {
                    // Add SubModel if not found with keiths way.
                    // I think it makes sense to add the model if the group is in the xmodel file.
                    const auto& newNames = wxSplit(grpModels, ',');
                    for (const auto& it : newNames) {
                        auto& mmnmn = mmg->ModelNames();
                        if (Contains(it, "/")) {
                            auto mgmn = wxString(it);
                            mgmn.Replace("EXPORTEDMODEL", mname);
                            if (std::find(mmnmn.begin(), mmnmn.end(), mgmn.ToStdString()) == mmnmn.end() &&
                                std::find(prevousNames.begin(), prevousNames.end(), mgmn) == prevousNames.end() &&
                                !mmg->DirectlyContainsModel(mgmn)) {
                                prevousNames.push_back(mgmn);
                                mmg->AddModel(mgmn);
                            }
                        }
                    }
                }
            }
            return;
        }
    }

    // create new groups
    std::string nn = mgname;
    int i = 1;
    while (models.find(nn) != models.end()) {
        nn = wxString::Format("%s_%d", mgname, i++).ToStdString();
    }
    
    // Create a temporary node with modified attributes to avoid using ModelXml
    wxXmlNode tempNode(*n);
    tempNode.DeleteAttribute("name");
    tempNode.AddAttribute("name", nn);
    
    // Fix model names by replacing EXPORTEDMODEL with the actual model name
    auto modelsList = Split(tempNode.GetAttribute("models").ToStdString(), ',');
    std::string fixedModels;
    for (auto& it : modelsList) {
        if (!fixedModels.empty()) fixedModels += ",";
        Replace(it, "EXPORTEDMODEL", mname);
        fixedModels += it;
    }
    tempNode.DeleteAttribute("models");
    tempNode.AddAttribute("models", fixedModels);
    
    // Use Deserialize to create the ModelGroup
    XmlDeserializingModelFactory factory;
    Model* model = factory.Deserialize(&tempNode, xlights, false);
    if (model != nullptr) {
        model->GetModelScreenLocation().previewW = w;
        model->GetModelScreenLocation().previewH = h;
        ModelGroup* mg = dynamic_cast<ModelGroup*>(model);
        if (mg != nullptr) {
            mg->RebuildBuffers();
            AddModel(mg);
        }
    }
}

bool ModelManager::RecalcStartChannels() const
{
    static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
    std::lock_guard<std::recursive_mutex> lock(_modelMutex);

    wxStopWatch sw;
    bool changed = false;
    std::set<std::string> modelsDone;
    std::set<std::string> modelsOnNoController;

    for (const auto& it : models) {
        it.second->CouldComputeStartChannel = false;
    }

    // first go through all models whose start channels are not dependent on other models
    for (const auto& it : models) {
        if (it.second->GetDisplayAs() != "ModelGroup") {
            char first = '0';
            if (!Trim(it.second->ModelStartChannel).empty())
                first = Trim(it.second->ModelStartChannel)[0];
            if (first != '>' && first != '@') {
                modelsDone.emplace(it.first);
                auto oldsc = it.second->GetFirstChannel();
                it.second->UpdateChannels();
                if (oldsc != it.second->GetFirstChannel()) {
                    changed = true;
                }
            }
            if (it.second->GetControllerName() == NO_CONTROLLER) {
                modelsOnNoController.emplace(it.first);
            }
        }
    }

    // now go through all undone models that depend on something
    bool workDone = false;
    do {
        workDone = false;

        for (const auto& it : models) {
            if (it.second->GetDisplayAs() != "ModelGroup") {
                char first = '0';
                if (!Trim(it.second->ModelStartChannel).empty())
                    first = Trim(it.second->ModelStartChannel)[0];
                if ((first == '>' || first == '@') && !it.second->CouldComputeStartChannel) {
                    std::string dependsOn = Trim(Trim(it.second->ModelStartChannel).substr(1, Trim(it.second->ModelStartChannel).find(':') - 1));

                    if (first == '>' && modelsOnNoController.find(dependsOn) != modelsOnNoController.end()) {
                        modelsOnNoController.emplace(it.first);
                    }

                    if (modelsDone.find(dependsOn) != modelsDone.end() && modelsOnNoController.find(dependsOn) == modelsOnNoController.end()) {
                        // the depends on model is done
                        modelsDone.emplace(it.first);
                        auto oldsc = it.second->GetFirstChannel();
                        it.second->UpdateChannels();
                        if (oldsc != it.second->GetFirstChannel()) {
                            changed = true;
                        }
                        if (it.second->CouldComputeStartChannel) {
                            workDone = true;
                        }
                    }
                }
            }
        }

    } while (workDone);

    // now process anything unprocessed
    int countInvalid = 0;
    for (const auto& it : models) {
        if (it.second->GetDisplayAs() != "ModelGroup") {
            char first = '0';
            if (!Trim(it.second->ModelStartChannel).empty())
                first = Trim(it.second->ModelStartChannel)[0];
            if ((first == '>' || first == '@') && !it.second->CouldComputeStartChannel) {
                modelsDone.emplace(it.first);
                auto oldsc = it.second->GetFirstChannel();
                it.second->UpdateChannels();
                if (oldsc != it.second->GetFirstChannel()) {
                    changed = true;
                }
            }
            if (!it.second->CouldComputeStartChannel) {
                countInvalid++;
            }
        }
    }

    ResetModelGroups();

    // Commenting out as this doesn't need to happen unless we have changes and when we do it is redundant as the only
    // current caller of this method, xLightsMain>>RecalcStartChannels, already adds RELOAD_MODELLIST work if changes exist
    // xlights->GetOutputModelManager()->AddASAPWork(OutputModelManager::WORK_RELOAD_MODELLIST, "RecalcStartChannels");

    long end = sw.Time();
    logger_base.debug("RecalcStartChannels takes %ldms.", end);

    if (countInvalid > 0) {
        DisplayStartChannelCalcWarning();
    }
    return changed;
}

void ModelManager::DisplayStartChannelCalcWarning() const
{
    static std::string lastwarn = "";
    std::string msg = "Could not calculate start channels for models:\n";
    std::lock_guard<std::recursive_mutex> lock(_modelMutex);
    for (const auto& it : models) {
        if (it.second->GetDisplayAs() != "ModelGroup" && !it.second->CouldComputeStartChannel) {
            msg += it.second->name + " : " + it.second->ModelStartChannel + "\n";
        }
    }

    if (msg != lastwarn) {
        DisplayWarning(msg);
        lastwarn = msg;
    }
}

bool ModelManager::IsValidControllerModelChain(Model* m, std::string& tip) const
{
    std::list<Model*> sameOutput;
    tip = "";
    auto controllerName = m->GetControllerName();
    if (controllerName.empty())
        return true; // we dont check these

    auto port = m->GetControllerPort();
    if (port == 0)
        return true; // we dont check these

    auto chain = m->GetModelChain();
    if (StartsWith(chain, ">")) {
        chain = chain.substr(1);
    }
    auto startModel = m->GetName();
    auto smartRemote = m->GetSmartRemote();
    auto isPixel = m->IsPixelProtocol();

    if (!isPixel) {
        // For DMX outputs then beginning is always ok
        if (chain.empty()) {
            return true;
        }
    }

    for (const auto& it : *this) {
        if (it.first != startModel) {
            if (it.second->GetControllerName() == controllerName && it.second->GetControllerPort() == port && it.second->GetSmartRemote() == smartRemote && it.second->IsPixelProtocol() == isPixel) {
                auto c = it.second->GetModelChain();
                if (StartsWith(c, ">")) {
                    c = c.substr(1);
                }

                // valid if no other model shares my chain
                if (chain == c) {
                    tip = "Model shares chain with " + it.second->GetName();
                    return false; // two models chain this place in the chain
                }
                sameOutput.push_back(it.second);
            }
        }
    }

    // if no other models then chain must be blank
    if (sameOutput.size() == 0) {
        if (!chain.empty())
            tip = "Only model on an output must not chain to anything.";
        return (chain.empty());
    }

    if (chain == "")
        return true; // this model is the beginning

    // valid if i can follow the chain to blank
    int checks = 0;
    std::string current = startModel;
    std::string next = chain;
    while (checks <= sameOutput.size()) {
        bool found = false;
        for (const auto& it : sameOutput) {
            if (it->GetName() == next) {
                next = it->GetModelChain();
                if (StartsWith(next, ">")) {
                    next = next.substr(1);
                }
                if (next.empty())
                    return true; // we found the beginning
                found = true;
                current = it->GetName();
                break;
            }
        }

        if (!found) {
            tip = "Chained to " + next + " but that model is not on this port";
            return false; // chained to non existent model
        }

        checks++;
    }
    tip = "Unable to find the beginning of the model chain on this output ... most likely you have a loop.";
    return false;
}

bool ModelManager::ReworkStartChannel() const
{
    static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
    static log4cpp::Category& logger_zcpp = log4cpp::Category::getInstance(std::string("log_zcpp"));
    static log4cpp::Category& logger_work = log4cpp::Category::getInstance(std::string("log_work"));
    logger_work.debug("        ReworkStartChannel.");

    bool outputsChanged = false;

    OutputManager* outputManager = xlights->GetOutputManager();
    for (const auto& it : outputManager->GetControllers()) {
        auto caps = it->GetControllerCaps();

        wxString serialPrefix;
        if (caps && caps->DMXAfterPixels()) {
            serialPrefix = "zzz";
        }

        std::map<std::string, std::list<Model*>> cmodels;
        std::lock_guard<std::recursive_mutex> lock(_modelMutex);
        for (auto itm : models) {
            if (itm.second->GetControllerName() == it->GetName() &&
                ((itm.second->GetControllerPort() != 0 && itm.second->GetControllerProtocol() != "") ||
                 (caps != nullptr && caps->GetMaxPixelPort() == 0 && caps->GetMaxSerialPort() == 0 && caps->GetMaxLEDPanelMatrixPort() == 0 && caps->GetMaxVirtualMatrixPort() == 0))) // we dont muck with unassigned models or no protocol models
            {
                wxString cc;
                if (IsPixelProtocol(itm.second->GetControllerProtocol())) {
                    cc = wxString::Format("%s:%02d:%02d", itm.second->GetControllerProtocol(), itm.second->GetControllerPort(), itm.second->GetSortableSmartRemote()).Lower();
                } else {
                    cc = wxString::Format("%s%s:%02d", serialPrefix, itm.second->GetControllerProtocol(), itm.second->GetControllerPort()).Lower();
                }
                if (cmodels.find(cc) == cmodels.end()) {
                    std::list<Model*> ml;
                    cmodels[cc] = ml;
                }
                cmodels[cc].push_back(itm.second);
            }
        }

        // first of all fix any weirdness ...
        for (const auto& itcc : cmodels) {
            logger_zcpp.debug("Fixing weirdness on %s - %s", (const char*)it->GetName().c_str(), (const char*)itcc.first.c_str());
            logger_zcpp.debug("    Models at start:");

            // build a list of model names on the port
            std::list<std::string> models;
            for (auto& itmm : itcc.second) {
                logger_zcpp.debug("        %s Chained to '%s'", (const char*)itmm->GetName().c_str(), (const char*)itmm->GetModelChain().c_str());
                models.push_back(itmm->GetName());
            }

            logger_zcpp.debug("    Fixing weirdness:");

            // If a model refers to a chained model not on the port then move it to beginning ... so next step can move it again
            bool beginningFound = false;
            for (const auto& itmm : itcc.second) {
                auto ch = itmm->GetModelChain();
                if (ch.empty() || ch == "Beginning") {
                    beginningFound = true;
                } else {
                    ch = ch.substr(1); // string off leading >
                    if (std::find(models.begin(), models.end(), ch) == models.end()) {
                        logger_zcpp.debug("    Model %s set to beginning because the model it is chained to '%s' does not exist.", (const char*)itmm->GetName().c_str(), (const char*)ch.c_str());
                        itmm->SetModelChain("");
                        beginningFound = true;
                        outputsChanged = true;
                    }
                }
            }

            // If no model is set as beginning ... then just make the first one beginning
            if (!beginningFound) {
                logger_zcpp.debug("    Model %s set to beginning because no other model was.", (const char*)itcc.second.front()->GetName().c_str());
                itcc.second.front()->SetModelChain("");
                outputsChanged = true;
            }

            // Now I would love to give any more than the first model a default to chain to but this is
            // not as easy as it looks ... so for now i am going to leave multiple models at the beginning
            // and let the user sort it out rather than creating loops
        }

        logger_zcpp.debug("    Sorting models:");
        int32_t ch = 1;
        std::list<Model*> allSortedModels;
        for (auto itcc = cmodels.begin(); itcc != cmodels.end(); ++itcc) {
            // order the models
            std::list<Model*> sortedmodels;
            std::string last = "";

            int32_t chstart = ch;

            if (itcc->second.size() > 0 && (itcc->second.front()->IsPixelProtocol() || itcc->second.front()->IsVirtualMatrixProtocol())) {
                while ((*itcc).second.size() > 0) {
                    bool pushed = false;
                    for (auto itms = itcc->second.begin(); itms != itcc->second.end(); ++itms) {
                        if ((((*itms)->GetModelChain() == "Beginning" || (*itms)->GetModelChain() == "") && last == "") ||
                            (*itms)->GetModelChain() == last ||
                            (*itms)->GetModelChain() == ">" + last) {
                            sortedmodels.push_back(*itms);
                            pushed = true;
                            last = (*itms)->GetName();
                            itcc->second.erase(itms);
                            break;
                        }
                    }

                    if (!pushed && (*itcc).second.size() > 0) {
                        // chain is broken ... so just put the rest in in the original order
                        // wxASSERT(false);
                        logger_zcpp.error("    Model chain is broken so just stuffing the remaining %d models in in their original order.", (*itcc).second.size());
                        while ((*itcc).second.size() > 0) {
                            sortedmodels.push_back(itcc->second.front());
                            itcc->second.pop_front();
                        }
                    }
                }
            } else if (itcc->second.front()->IsLEDPanelMatrixProtocol()) {
                while ((*itcc).second.size() > 0) {
                    sortedmodels.push_back((*itcc).second.front());
                    (*itcc).second.pop_front();
                }
            } else {
                // dmx protocols work differently ... they can be chained or by specified dmx channel
                int dmx = 1;
                while ((*itcc).second.size() > 0 && dmx <= 512) {
                    for (auto itms = itcc->second.begin(); itms != itcc->second.end(); ++itms) {
                        if (((*itms)->GetModelChain() == "Beginning" || (*itms)->GetModelChain() == "") && (*itms)->GetControllerDMXChannel() == dmx) {
                            sortedmodels.push_back(*itms);
                            last = (*itms)->GetName();
                            itcc->second.erase(itms);
                            break;
                        } else if (last != "" && ((*itms)->GetModelChain() == last || (*itms)->GetModelChain() == ">" + last)) {
                            sortedmodels.push_back(*itms);
                            last = (*itms)->GetName();
                            itcc->second.erase(itms);
                            break;
                        }
                    }
                    dmx++;
                }

                if ((*itcc).second.size() > 0) {
                    // models left over so stuff them on the end
                    logger_zcpp.error("    DMX Model chain is broken or there are duplicate models so just stuffing the remaining %d models in in their original order.", (*itcc).second.size());
                    while ((*itcc).second.size() > 0) {
                        sortedmodels.push_back(itcc->second.front());
                        itcc->second.pop_front();
                    }
                }
            }

            for (auto itm : sortedmodels) {
                std::string sc = "";
                if (itm->IsPixelProtocol() || itm->IsVirtualMatrixProtocol()) {
                    if (itm->GetModelChain() == last ||
                        itm->GetModelChain() == ">" + last ||
                        ((itm->GetModelChain() == "Beginning" || itm->GetModelChain() == "") && last == "")) {
                        std::string osc = itm->ModelStartChannel;
                        sc = "!" + it->GetName() + ":" + wxString::Format("%d", ch);
                        itm->SetStartChannel(sc);
                        itm->ClearIndividualStartChannels();
                        last = itm->GetName();
                        ch += itm->GetChanCount();
                        if (osc != itm->ModelStartChannel) {
                            outputsChanged = true;
                        }
                    } else {
                        std::string osc = itm->ModelStartChannel;
                        sc = "!" + it->GetName() + ":" + wxString::Format("%d", chstart);
                        itm->SetStartChannel(sc);
                        itm->ClearIndividualStartChannels();
                        last = itm->GetName();
                        ch = std::max(ch, (int32_t)(chstart + itm->GetChanCount()));
                        if (osc != itm->ModelStartChannel) {
                            outputsChanged = true;
                        }
                    }
                } else if (itm->IsLEDPanelMatrixProtocol()) {
                    // This code only allows one model on a LED Matrix panel ... and I am not sure this is a valid limitation
                    // so if this is a chained model ... move it off the controller
                    if (itm->GetModelChain() != "Beginning" && itm->GetModelChain() != "") {
                        itm->SetControllerName(NO_CONTROLLER);

                        // because we have now moved a model off a controller we really need to do this all again
                        xlights->GetOutputModelManager()->AddASAPWork(OutputModelManager::WORK_MODELS_REWORK_STARTCHANNELS, "ReworkStartChannel");

                        logger_base.warn("Attempt to place a second model %s on led panel port when only one is allowed. Only the first model has been retained. The others have been removed.", (const char*)itm->GetName().c_str());

                    } else {
                        std::string osc = itm->ModelStartChannel;
                        sc = "!" + it->GetName() + ":" + wxString::Format("%d", chstart);
                        itm->SetStartChannel(sc);
                        itm->ClearIndividualStartChannels();
                        last = itm->GetName();
                        ch = std::max(ch, (int32_t)(chstart + itm->GetChanCount()));
                        if (osc != itm->ModelStartChannel) {
                            outputsChanged = true;
                        }
                    }
                } else {
                    // Handle controllers that must start serial outputs on a new universe and the first model is not DMX port 1
                    // This relies on serial ports being added first to any controller channels
                    if (itm == sortedmodels.front()) {
                        if ((it->GetProtocol() == OUTPUT_E131 || it->GetProtocol() == OUTPUT_ARTNET) && caps && caps->NeedsFullUniverseForDMX()) {
                            ch += itm->GetControllerDMXChannel() - 1;
                        }
                    }

                    // when chained the use next channel
                    if (last != "" && itm->GetControllerDMXChannel() == 0 &&
                        (itm->GetModelChain() == last ||
                         itm->GetModelChain() == ">" + last)) {
                        auto osc = itm->ModelStartChannel;
                        sc = "!" + it->GetName() + ":" + wxString::Format("%d", ch);
                        itm->SetStartChannel(sc);
                        itm->ClearIndividualStartChannels();
                        last = itm->GetName();
                        ch += itm->GetChanCount();
                        if (osc != itm->ModelStartChannel) {
                            outputsChanged = true;
                        }
                    } else {
                        // when not chained use dmx channel
                        uint32_t msc = chstart + itm->GetControllerDMXChannel() - 1;
                        std::string osc = itm->ModelStartChannel;
                        sc = "!" + it->GetName() + ":" + wxString::Format("%d", msc);
                        itm->SetStartChannel(sc);
                        itm->ClearIndividualStartChannels();
                        last = itm->GetName();
                        ch = std::max(ch, (int32_t)msc + (int32_t)itm->GetChanCount());
                        if (osc != itm->ModelStartChannel) {
                            outputsChanged = true;
                        }
                    }

                    // Handle controllers that must start serial outputs on a new universe last model does not consume the full universe
                    if ((it->GetProtocol() == OUTPUT_E131 || it->GetProtocol() == OUTPUT_ARTNET) && caps && caps->NeedsFullUniverseForDMX()) {
                        if (itm == sortedmodels.back()) {
                            int unisize = it->GetFirstOutput()->GetChannels();
                            if ((ch - 1) % unisize != 0) {
                                ch += unisize - ((ch - 1) % unisize);
                            }
                        }
                    }
                }

                logger_zcpp.debug("    Model %s on port %d chained to %s start channel %s.",
                                  (const char*)itm->GetName().c_str(),
                                  itm->GetControllerPort(),
                                  (const char*)itm->GetModelChain().c_str(),
                                  (const char*)sc.c_str());
            }

            allSortedModels.splice(allSortedModels.end(), sortedmodels);
        }

        if (it->IsAutoSize()) {
            auto eth = dynamic_cast<const ControllerEthernet*>(it);
            if (it->GetChannels() != std::max((int32_t)1, (int32_t)ch - 1) || (eth != nullptr && eth->SupportsUniversePerString())) {
                logger_zcpp.debug("    Resizing output to %d channels.", std::max((int32_t)1, (int32_t)ch - 1));

                auto oldC = it->GetChannels();
                // Set channel size won't always change the number of channels for some protocols
                it->SetChannelSize(std::max((int32_t)1, (int32_t)ch - 1), allSortedModels);
                if (it->GetChannels() != oldC || (eth != nullptr && eth->SupportsUniversePerString())) {
                    outputManager->SomethingChanged();

                    if (it->GetChannels() != oldC || (eth != nullptr && eth->IsUniversePerString() && xlights->IsSequencerInitialize())) { 
                        xlights->GetOutputModelManager()->AddASAPWork(OutputModelManager::WORK_NETWORK_CHANGE, "ReworkStartChannel");
                    }
                    xlights->GetOutputModelManager()->AddASAPWork(OutputModelManager::WORK_NETWORK_CHANNELSCHANGE, "ReworkStartChannel");
                    xlights->GetOutputModelManager()->AddASAPWork(OutputModelManager::WORK_UPDATE_NETWORK_LIST, "ReworkStartChannel");
                    xlights->GetOutputModelManager()->AddASAPWork(OutputModelManager::WORK_SAVE_NETWORKS, "ReworkStartChannel");
                    xlights->GetOutputModelManager()->AddASAPWork(OutputModelManager::WORK_RESEND_CONTROLLER_CONFIG, "ReworkStartChannel");
                }
            }
        }
    }

    // now we want to deal with any models specified as being on "No Controller"
    // first we need to work out the last used channel by all controllers and models other than those on No Controller
    uint32_t lastChannel = 0;
    for (const auto& it : outputManager->GetControllers()) {
        lastChannel = std::max(lastChannel, (uint32_t)it->GetEndChannel());
    }

    std::list<std::string> modelsToSet;
    {
        std::lock_guard<std::recursive_mutex> lock(_modelMutex);
        for (auto itm : models) {
            std::list<std::string> visited;
            if (ModelHasNoDependencyOnNoController(itm.second, visited) || itm.second->GetControllerName() == NO_CONTROLLER) {
                if (itm.second->GetControllerName() != NO_CONTROLLER) {
                    lastChannel = std::max(lastChannel, itm.second->GetLastChannel() + 1);
                } else {
                    modelsToSet.push_back(itm.first);
                }
            }
        }
    }

    // now we need to go through the models in a deterministic order and assign them ... so we sort them first
    modelsToSet.sort();
    for (const auto& it : modelsToSet) {
        Model* m = GetModel(it);
        auto osc = m->ModelStartChannel;
        m->SetStartChannel(wxString::Format("%u", lastChannel + 1));
        m->ClearIndividualStartChannels();
        lastChannel += m->GetChanCount();
        if (osc != m->ModelStartChannel) {
            outputsChanged = true;
        }
    }

    return outputsChanged;
}

bool ModelManager::ModelHasNoDependencyOnNoController(Model* m, std::list<std::string>& visited) const
{
    if (std::find(visited.begin(), visited.end(), m->GetName()) != visited.end())
        return false;

    visited.push_back(m->GetName());

    if (!m->CouldComputeStartChannel) // this should stop this looping forever due to chain loops
        return false;

    wxString sc = m->ModelStartChannel;
    if (sc != "" && (sc[0] == '>' || sc[0] == '@')) {
        std::string dependson = sc.substr(1).BeforeFirst(':');
        Model* mm = GetModel(dependson);
        if (mm != nullptr) {
            if (mm->GetControllerName() == NO_CONTROLLER)
                return false;
            return ModelHasNoDependencyOnNoController(mm, visited);
        }
    }

    return true;
}

bool ModelManager::LoadGroups(wxXmlNode* groupNode, int previewW, int previewH)
{
    // static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
    // logger_base.debug("ModelManager loading groups.");
   this->groupNode = groupNode;
    bool changed = false;
    std::list<wxXmlNode*> toBeDone;
    std::set<std::string> allModels;
    std::lock_guard<std::recursive_mutex> lock(_modelMutex);
    XmlDeserializingModelFactory factory;

    // do all the models without embedded groups first or where the model order means everything exists
    for (wxXmlNode* e = groupNode->GetChildren(); e != nullptr; e = e->GetNext()) {
        if (e->GetName() == "modelGroup") {
            std::string name = e->GetAttribute("name").ToStdString();
            if (!name.empty()) {
                allModels.insert(name);
                if (ModelGroup::AllModelsExist(e, *this)) {
                    Model* model = factory.Deserialize(e, xlights, false);
                    if (model != nullptr) {
                        model->GetModelScreenLocation().previewW = previewW;
                        model->GetModelScreenLocation().previewH = previewH;
                        ModelGroup* mg = dynamic_cast<ModelGroup*>(model);
                        if (mg != nullptr) {
                            mg->RebuildBuffers();
                            models[model->name] = model;
                        }
                    }
                } else {
                    toBeDone.push_back(e);
                }
            }
        }
    }

    // add in models and SubModels
    for (const auto& it : models) {
        allModels.insert(it.second->GetName());
        for (auto it2 : it.second->GetSubModels()) {
            allModels.insert(it2->GetFullName());
        }
    }

    // remove any totally non existent models from model groups
    // this stops some end conditions which cant be resolved
    for (const auto& it : toBeDone) {
        changed |= ModelGroup::RemoveNonExistentModels(it, allModels);
    }

    // try up to however many models we have left
    int maxIter = toBeDone.size();
    while (maxIter > 0 && toBeDone.size() > 0) {
        maxIter--;
        std::list<wxXmlNode*> processing(toBeDone);
        toBeDone.clear();
        for (const auto& it : processing) {
            if (ModelGroup::AllModelsExist(it, *this)) {
                Model* model = factory.Deserialize(it, xlights, false);
                if (model != nullptr) {
                    model->GetModelScreenLocation().previewW = previewW;
                    model->GetModelScreenLocation().previewH = previewH;
                    ModelGroup* mg = dynamic_cast<ModelGroup*>(model);
                    if (mg != nullptr) {
                        bool reset = mg->RebuildBuffers();
                        wxASSERT(reset);
                        models[model->name] = model;
                    }
                }
            } else {
                toBeDone.push_back(it);
            }
        }
    }

    // anything left in toBeDone is now due to model loops
    for (const auto& it : toBeDone) {
        std::string name = it->GetAttribute("name").ToStdString();
        std::string msg = "Could not process model group " + name + " likely due to model groups loops. See Check Sequence for details.";
        DisplayWarning(msg);
        wxASSERT(false);
        Model* model = factory.Deserialize(it, xlights, false);
        if (model != nullptr) {
            model->GetModelScreenLocation().previewW = previewW;
            model->GetModelScreenLocation().previewH = previewH;
            ModelGroup* mg = dynamic_cast<ModelGroup*>(model);
            if (mg != nullptr) {
                bool reset = mg->RebuildBuffers();
                wxASSERT(!reset);
                models[model->name] = model;
            }
        }
    }

    return changed;
}

bool ModelManager::RenameController(const std::string& oldName, const std::string& newName)
{
    bool changed = false;

    for (auto& it : *this) {
        changed |= it.second->RenameController(oldName, newName);
    }

    return changed;
}

// generate the next similar model name to the candidateName we are given
std::string ModelManager::GenerateModelName(const std::string& candidateName) const
{
    lastGeneratedModelName = GenerateObjectName(candidateName);
    return GetLastGeneratedModelName();
}

Model* ModelManager::CreateDefaultModel(const std::string& type, const std::string& startChannel) const
{
    Model* model;

    std::string type_conversion = type;
    std::string protocol = "ws2811";
    int parm1 = 1;
    int parm2 = 50;
    int parm3 = 1;

    if (type == "Star") {
        model = new StarModel(*this);
        parm3 = 5;
        dynamic_cast<StarModel*>(model)->SetStarStartLocation("Bottom Ctr-CW");
    } else if (type == "Arches") {
        model = new ArchesModel(*this);
    } else if (type == "Candy Canes") {
        model = new CandyCaneModel(*this);
        parm1 = 3;
        parm2 = 18;
    } else if (type == "Channel Block") {
        model = new ChannelBlockModel(*this);
        parm1 = 16;
        protocol = xlEMPTY_STRING;
        model->SetStringType("Single Color White");
        model->SetPixelSize(12);
    } else if (type == "Circle") {
        model = new CircleModel(*this);
        parm3 = 50;
        dynamic_cast<CircleModel*>(model)->SetInsideOut(false);
    } else if (type == "DmxMovingHead") {
        model = new DmxMovingHead(*this);
        protocol = xlEMPTY_STRING;
        parm1 = 8;
        parm2 = 1;
        dynamic_cast<DmxMovingHead*>(model)->SetDmxStyle("Moving Head Top");
        model->SetStringType("Single Color White");
    } else if (type == "DmxGeneral") {
        model = new DmxGeneral(*this);
        protocol = xlEMPTY_STRING;
        parm1 = 8;
        parm2 = 1;
        parm3 = 1;
        model->SetStringType("Single Color White");
    } else if (type == "DmxMovingHeadAdv") {
        model = new DmxMovingHeadAdv(*this);
        protocol = xlEMPTY_STRING;
        parm1 = 8;
        parm2 = 1;
        model->SetStringType("Single Color White");
    } else if (type == "DmxFloodlight") {
        model = new DmxFloodlight(*this);
        parm1 = 3;
        parm2 = 1;
        model->SetStringType("Single Color White");
    } else if (type == "DmxFloodArea") {
        model = new DmxFloodArea(*this);
        protocol = xlEMPTY_STRING;
        parm1 = 3;
        parm2 = 1;
        model->SetStringType("Single Color White");
    } else if (type == "DmxSkull") {
        model = new DmxSkull(*this);
        protocol = xlEMPTY_STRING;
        parm1 = 26;
        parm2 = 1;
        model->SetStringType("Single Color White");
    } else if (type == "DmxServo") {
        model = new DmxServo(*this);
        protocol = xlEMPTY_STRING;
        parm1 = 2;
        parm2 = 1;
        model->SetStringType("Single Color White");
    } else if (type == "DmxServo3d" || type == "DmxServo3Axis") {
        model = new DmxServo3d(*this);
        protocol = xlEMPTY_STRING;
        parm1 = 2;
        parm2 = 1;
        model->SetStringType("Single Color White");
        if (type == "DmxServo3Axis") {
            dynamic_cast<DmxServo3d*>(model)->SetNumServos(3);
            dynamic_cast<DmxServo3d*>(model)->SetNumStatic(1);
            dynamic_cast<DmxServo3d*>(model)->SetNumMotion(3);
            model->SetParm1(6);
            model->SetDisplayAs("DmxServo3d");
        }
    } else if (type == "Image") {
        model = new ImageModel(*this);
        protocol = xlEMPTY_STRING;
        parm1 = 1;
        parm2 = 1;
        dynamic_cast<ImageModel*>(model)->SetImageFile("");
        model->SetStringType("Single Color White");
    } else if (type == "Window Frame") {
        model = new WindowFrameModel(*this);
        parm1 = 16;
        parm3 = 16;
    } else if (type == "Wreath") {
        model = new WreathModel(*this);
    } else if (type.find("Sphere") == 0) {
        model = new SphereModel(*this);
        parm1 = 10;
        parm2 = 10;
    } else if (type == "Single Line") {
        model = new SingleLineModel(*this);
    } else if (type == "Poly Line") {
        model = new PolyLineModel(*this);
    } else if (type == "MultiPoint") {
        model = new MultiPointModel(*this);
    } else if (type == "Cube") {
        model = new CubeModel(*this);
        parm1 = 5;
        parm2 = 5;
        parm3 = 5;
        dynamic_cast<CubeModel*>(model)->SetCubeStyle("Horizontal Left/Right");
    } else if (type == "Custom") {
        model = new CustomModel(*this);
        parm1 = 5;
        parm2 = 5;
    } else if (type.find("Tree") == 0) {
        model = new TreeModel(*this);
        parm1 = 16;
    } else if (type == "Matrix") {
        model = new MatrixModel(*this);
        parm1 = 16;
        model->SetStartSide("T");
    } else if (type == "Spinner") {
        model = new SpinnerModel(*this);
        parm2 = 10;
        parm3 = 5;
    } else if (type == "Icicles") {
        model = new IciclesModel(*this);
        parm2 = 80;
        dynamic_cast<IciclesModel*>(model)->SetDropPattern("3,4,5,4");
    } else {
        DisplayError(wxString::Format("'%s' is not a valid model type for a model", type));
        return nullptr;
    }

    model->SetControllerProtocol(protocol);
    model->SetControllerName(NO_CONTROLLER);

    model->SetName(GenerateModelName(type));
    model->SetDisplayAs(type);
    model->SetStartChannel(startChannel);
    model->SetParm1(parm1);
    model->SetParm2(parm2);
    model->SetParm3(parm3);
    
    model->Setup();

    return model;
}

Model* ModelManager::CreateModel(wxXmlNode* node, int previewW, int previewH) const
{
    if (node->GetName() == "modelGroup") {
        XmlDeserializingModelFactory factory;
        return factory.Deserialize(node, xlights, false);
    }

    Model* model;
    XmlSerializer serializer;
    model = serializer.DeserializeModel(node, xlights, false);
    
    if (model != nullptr) {
        model->GetModelScreenLocation().previewW = previewW;
        model->GetModelScreenLocation().previewH = previewH;
    }

    return model;
}

void ModelManager::AddModel(Model* model)
{
    // Lock before we add models ... this is required because LoadModels loads this in parallel

    if (model != nullptr) {
        std::lock_guard<std::recursive_mutex> _lock(_modelMutex);
        auto it = models.find(model->name);
        if (it != models.end()) {
            delete it->second;
            it->second = nullptr;
            ResetModelGroups();
        }
        models[model->name] = model;
    }
}

void ModelManager::ReplaceModel(const std::string &name, Model* nm) {
    if (nm != nullptr && name != "") {
        std::lock_guard<std::recursive_mutex> _lock(_modelMutex);
        Model *oldm = models[name];
        models[nm->name] = nm;
        ResetModelGroups();       
        delete oldm;
    }
}

Model* ModelManager::createAndAddModel(wxXmlNode* node, int previewW, int previewH)
{
    Model* model = CreateModel(node, previewW, previewH);
    AddModel(model);
    return model;
}

std::string ModelManager::GetModelsOnChannels(uint32_t start, uint32_t end, int perLine) const
{
    std::string res;
    std::string line;

    for (const auto& it : *this) {
        if (it.second->GetDisplayAs() != "ModelGroup") {
            if (perLine > 0 && CountChar(line, ',') >= perLine - 1) {
                if (res != "")
                    res += "\n";
                res += line;
                line = "";
            }
            if (it.second->GetFirstChannel() + 1 <= end && it.second->GetLastChannel() + 1 >= start) {
                if (line != "")
                    line += ", ";
                line += it.first;
            }
        }
    }

    if (line != "") {
        if (res != "")
            res += "\n";
        res += line;
    }

    return res;
}

std::vector<std::string> ModelManager::GetGroupsContainingModel(const Model* model) const
{
    std::vector<std::string> res;
    if (model == nullptr) {
        static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
        logger_base.error("ModelManager::GetGroupsContainingModel called with nullptr");
        return res;
    }

    for (const auto& it : *this) {
        if (it.second->GetDisplayAs() == "ModelGroup") {
            auto mg = dynamic_cast<ModelGroup*>(it.second);
            if (mg == nullptr) {
                static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
                logger_base.error("ModelManager::GetGroupsContainingModel - Model '%s' claims to be ModelGroup but cast failed", 
                    it.first.c_str());
                continue;
            }
            if (mg->ContainsModel(model)) {
                res.push_back(it.first);
            } else {
                for (const auto& sm : model->GetSubModels()) {
                    if (mg->ContainsModel(sm)) {
                        res.push_back(it.first);
                        break;
                    }
                }
            }
        }
    }
    return res;
}

std::vector<std::string> ModelManager::GetGroupsContainingModelOrSubmodel(const Model* model) const
{
    std::vector<std::string> res;
    for (const auto& it : *this) {
        if (it.second->GetDisplayAs() == "ModelGroup") {
            auto mg = dynamic_cast<ModelGroup*>(it.second);
            if (mg->ContainsModelOrSubmodel(model)) {
                res.push_back(it.first);
            } else {
                for (const auto& sm : model->GetSubModels()) {
                    if (mg->ContainsModelOrSubmodel(sm)) {
                        res.push_back(it.first);
                        break;
                    }
                }
            }
        }
    }
    return res;
}

std::vector<Model*> ModelManager::GetModelGroups(const Model* model) const {
    std::vector<Model*> res;
    for (const auto& it : *this) {
        if (it.second->GetDisplayAs() == "ModelGroup") {
            auto mg = dynamic_cast<ModelGroup*>(it.second);
            if (mg->ContainsModel(model)) {
                res.push_back(mg);
            }
        }
    }
    return res;
}

std::string ModelManager::GenerateNewStartChannel(const std::string& lastModel) const
{
    std::string startChannel = "1";

    if (!lastModel.empty() && models.count(lastModel) > 0) {
        startChannel = ">" + lastModel + ":1";
    } else {
        unsigned int highestch = 0;
        Model* highest = nullptr;
        for (const auto& it : models) {
            if (it.second->GetDisplayAs() != "ModelGroup") {
                if (it.second->GetLastChannel() > highestch) {
                    highestch = it.second->GetLastChannel();
                    highest = it.second;
                }
            }
        }
        if (highest != nullptr) {
            startChannel = ">" + highest->GetName() + ":1";
        }
    }
    return startChannel;
}

std::string MergeModels(const std::string& ml1, const std::string& ml2)
{
    std::string res = "";

    std::list<std::string> models;

    std::istringstream lineStream(ml1);
    std::string cell;
    while (std::getline(lineStream, cell, ',')) {
        if (std::find(begin(models), end(models), cell) == end(models))
            models.push_back(cell);
    }

    lineStream = std::istringstream(ml2);
    while (std::getline(lineStream, cell, ',')) {
        if (std::find(begin(models), end(models), cell) == end(models))
            models.push_back(cell);
    }

    for (const auto& it : models) {
        if (res != "")
            res += ",";
        res += it;
    }

    return res;
}

// Helper: find a child XML node with a given tag name and "name" attribute value
static wxXmlNode* FindChildByNameAttr(wxXmlNode* parent, const wxString& childTag, const wxString& name)
{
    for (wxXmlNode* n = parent->GetChildren(); n != nullptr; n = n->GetNext()) {
        if (n->GetName() == childTag && n->GetAttribute("name") == name) {
            return n;
        }
    }
    return nullptr;
}

// Helper: set an attribute on a node (delete + re-add pattern)
static void SetXmlAttribute(wxXmlNode* node, const wxString& attr, const wxString& value)
{
    if (node->HasAttribute(attr)) node->DeleteAttribute(attr);
    node->AddAttribute(attr, value);
}

// Helper: compare name attributes on child nodes for XML comparison
static bool CheckNameAttrs(wxXmlNode* nn, wxXmlNode* cc)
{
    if (nn->HasAttribute("name")) {
        return (cc->GetAttribute("name") == nn->GetAttribute("name"));
    } else if (nn->HasAttribute("Name")) {
        return (cc->GetAttribute("Name") == nn->GetAttribute("Name"));
    }
    return true;
}


static std::set<std::string> FLOAT_ATTRIBUTES = {
    XmlNodeKeys::WorldPosXAttribute,
    XmlNodeKeys::WorldPosYAttribute,
    XmlNodeKeys::WorldPosZAttribute,
    XmlNodeKeys::RotateXAttribute,
    XmlNodeKeys::RotateYAttribute,
    XmlNodeKeys::RotateZAttribute,
    XmlNodeKeys::ScaleXAttribute,
    XmlNodeKeys::ScaleYAttribute,
    XmlNodeKeys::ScaleZAttribute,
    XmlNodeKeys::LengthAttribute,
    XmlNodeKeys::X2Attribute,
    XmlNodeKeys::Y2Attribute,
    XmlNodeKeys::Z2Attribute,
};

#ifdef DEBUG_MERGEFROMBASE
static std::set<std::string> IGNORE_ATTRIBUTES = {
    "ModelBrightness",
    "RotateX",
    "CustomModel"
};
#endif
static std::set<std::string> BASE_EMPTY = {
    "StrandNames",
    "NodeNames",
    "PixelSpacing",
    "PixelCount",
    "PixelType"
};

// Helper: compare two XML nodes to detect changes (standalone version operating on raw nodes)
static bool IsXmlNodeChanged(wxXmlNode* local, wxXmlNode* base)
{
    // Check if base has attributes that differ from local
    bool changed = false;
    for (wxXmlAttribute* a = base->GetAttributes(); a != nullptr; a = a->GetNext()) {
        if (!local->HasAttribute(a->GetName()) || local->GetAttribute(a->GetName()) != a->GetValue()) {
            if (a->GetName() != "StartChannel" || !local->HasAttribute("Controller")) {
                // For float attributes, compare rounded to 4 decimal places as older versions of xLights only output to 4 decimals
                if (FLOAT_ATTRIBUTES.count(a->GetName().ToStdString()) > 0 && local->HasAttribute(a->GetName())) {
                    double baseVal = 0.0, localVal = 0.0;
                    a->GetValue().ToDouble(&baseVal);
                    local->GetAttribute(a->GetName()).ToDouble(&localVal);
                    if (std::round(baseVal * 10000.0) == std::round(localVal * 10000.0)) {
                        continue;
                    }
                }
                // In some cases, old versions of xLights would put an empty attribute but the new version will not put the attribute at all.
                if (!(BASE_EMPTY.contains(a->GetName().ToStdString()) && a->GetValue().IsEmpty() && !local->HasAttribute(a->GetName()))) {
#ifdef DEBUG_MERGEFROMBASE
                    if (!changed) {
                        printf("%s\n", local->GetAttribute("name").ToStdString().c_str());
                    }
                    printf("  %s:  %s\n", a->GetName().ToStdString().c_str(), a->GetValue().ToStdString().c_str());
                    printf("          %s\n", local->GetAttribute(a->GetName()).ToStdString().c_str());
                    changed = true;
#else
                    return true;
#endif
                }
            }
        }
    }
    if (changed) {
        return true;
    }

    // Check child nodes
    for (wxXmlNode* nn = base->GetChildren(); nn != nullptr; nn = nn->GetNext()) {
        bool found = false;
        for (wxXmlNode* cc = local->GetChildren(); cc != nullptr; cc = cc->GetNext()) {
            if (cc->GetName() == nn->GetName() && CheckNameAttrs(nn, cc)) {
                found = true;
                for (wxXmlAttribute* a = nn->GetAttributes(); a != nullptr; a = a->GetNext()) {
                    if (!cc->HasAttribute(a->GetName()) || cc->GetAttribute(a->GetName()) != a->GetValue()) {
                        return true;
                    }
                }
            }
        }
        if (!found) {
            return true;
        }
    }
    return false;
}

// Helper: copy preserved local controller attributes onto a new node replacing a FromBase model
static void PreserveLocalControllerAttrs(wxXmlNode* localNode, wxXmlNode* newNode)
{
    // Find the local port from ControllerConnection child
    wxString port;
    for (wxXmlNode* p = localNode->GetChildren(); p != nullptr; p = p->GetNext()) {
        if (p->GetName() == "ControllerConnection") {
            port = p->GetAttribute("Port");
        }
    }

    if (!port.empty()) {
        // Preserve ModelChain if local has one
        wxString modelChain = localNode->GetAttribute("ModelChain");
        if (!modelChain.empty()) {
            SetXmlAttribute(newNode, "ModelChain", modelChain);
        }
        SetXmlAttribute(newNode, "StartChannel", localNode->GetAttribute("StartChannel"));
        SetXmlAttribute(newNode, "Controller", localNode->GetAttribute("Controller"));
    }
}

// Helper: copy the local ControllerConnection port onto the new node's ControllerConnection child if it has no port
static void PreserveLocalControllerPort(wxXmlNode* localNode, wxXmlNode* newNode)
{
    wxString port;
    for (wxXmlNode* p = localNode->GetChildren(); p != nullptr; p = p->GetNext()) {
        if (p->GetName() == "ControllerConnection") {
            port = p->GetAttribute("Port");
        }
    }
    if (!port.empty()) {
        for (wxXmlNode* bp = newNode->GetChildren(); bp != nullptr; bp = bp->GetNext()) {
            if (bp->GetName() == "ControllerConnection") {
                if (!bp->HasAttribute("Port")) {
                    bp->AddAttribute("Port", port);
                }
            }
        }
    }
}
static void RemoveControllerConnection(wxXmlNode *node) {
    for (wxXmlNode* p = node->GetChildren(); p != nullptr; p = p->GetNext()) {
        if (p->GetName() == "ControllerConnection") {
            node->RemoveChild(p);
            return;
        }
    }
}

// Shared method: merge base XML into current XML, updating currentModelsNode and currentGroupsNode in-place.
// Populates changedModels and changedGroups with names of models/groups that were added or updated.
// Only updates models/groups that are new or have FromBase="1" on the current side.
static bool MergeBaseIntoCurrentXml(wxXmlNode* currentModelsNode, wxXmlNode* currentGroupsNode,
                                    wxXmlNode* baseModelsNode, wxXmlNode* baseGroupsNode,
                                    std::vector<std::string>& changedModels,
                                    std::vector<std::string>& changedGroups)
{
    static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
    bool changed = false;

    if (baseModelsNode != nullptr && currentModelsNode != nullptr) {
        for (wxXmlNode* bm = baseModelsNode->GetChildren(); bm != nullptr; bm = bm->GetNext()) {
            if (bm->GetName() != "model") continue;
            auto name = bm->GetAttribute("name");
            if (name.empty()) continue;

            wxXmlNode* local = FindChildByNameAttr(currentModelsNode, "model", name);

            if (local == nullptr) {
                // Model does not exist locally -- add it
                wxXmlNode* copy = new wxXmlNode(*bm);
                SetXmlAttribute(copy, "FromBase", "1");
                currentModelsNode->AddChild(copy);
                changedModels.push_back(name.ToStdString());
                changed = true;
                logger_base.debug("MergeBase: Adding model from base: '%s'.", (const char*)name.c_str());
            } else if (local->GetAttribute("FromBase") == "1") {
                // Model exists and came from base -- update if changed
                if (IsXmlNodeChanged(local, bm)) {
                    wxXmlNode* copy = new wxXmlNode(*bm);
                    SetXmlAttribute(copy, "FromBase", "1");
                    PreserveLocalControllerAttrs(local, copy);
                    PreserveLocalControllerPort(local, copy);

                    currentModelsNode->InsertChildAfter(copy, local);
                    currentModelsNode->RemoveChild(local);
                    delete local;
                    changedModels.push_back(name.ToStdString());
                    changed = true;
                    logger_base.debug("MergeBase: Updating model from base: '%s'.", (const char*)name.c_str());
                }
            }
            // If model exists locally without FromBase, skip silently
        }
    }

    if (baseGroupsNode != nullptr && currentGroupsNode != nullptr) {
        for (wxXmlNode* bg = baseGroupsNode->GetChildren(); bg != nullptr; bg = bg->GetNext()) {
            if (bg->GetName() != "modelGroup") continue;
            auto name = bg->GetAttribute("name");
            if (name.empty()) continue;

            wxXmlNode* local = FindChildByNameAttr(currentGroupsNode, "modelGroup", name);

            if (local == nullptr) {
                // Group does not exist locally -- add it
                wxXmlNode* copy = new wxXmlNode(*bg);
                SetXmlAttribute(copy, "FromBase", "1");
                currentGroupsNode->AddChild(copy);
                changedGroups.push_back(name.ToStdString());
                changed = true;
                logger_base.debug("MergeBase: Adding model group from base: '%s'.", (const char*)name.c_str());
            } else if (local->GetAttribute("FromBase") == "1") {
                // Group exists and came from base -- merge model lists and update if changed
                auto baseModelList = bg->GetAttribute("models");
                auto localModelList = local->GetAttribute("models");
                std::string mergedList = MergeModels(baseModelList.ToStdString(), localModelList.ToStdString());

                // Create a temp copy with merged model list to compare
                wxXmlNode* copy = new wxXmlNode(*bg);
                SetXmlAttribute(copy, "models", mergedList);
                SetXmlAttribute(copy, "FromBase", "1");
                copy->DeleteAttribute("selected");
                copy->DeleteAttribute("BaseModels");

                RemoveControllerConnection(copy);

                // Remove ControllerConnection from local copy for comparison purposes only
                wxXmlNode localCopy(*local);
                RemoveControllerConnection(&localCopy);

                if (IsXmlNodeChanged(&localCopy, copy)) {
                    SetXmlAttribute(copy, "BaseModels", baseModelList);
                    // Preserve local X/Y centre offsets
                    wxString xOffset = local->GetAttribute("GridCentreX", "");
                    wxString yOffset = local->GetAttribute("GridCentreY", "");
                    if (!xOffset.empty()) SetXmlAttribute(copy, "GridCentreX", xOffset);
                    if (!yOffset.empty()) SetXmlAttribute(copy, "GridCentreY", yOffset);

                    currentGroupsNode->InsertChildAfter(copy, local);
                    currentGroupsNode->RemoveChild(local);
                    delete local;
                    changedGroups.push_back(name.ToStdString());
                    changed = true;
                    logger_base.debug("MergeBase: Updating model group from base: '%s'.", (const char*)name.c_str());
                } else {
                    delete copy;
                }
            }
            // If group exists locally without FromBase, skip silently
        }
    }

    return changed;
}

// Load base XML document and find <models> and <modelGroups> nodes
static bool LoadBaseXmlNodes(const std::string& baseShowDir, wxXmlDocument& doc,
                             wxXmlNode*& baseModels, wxXmlNode*& baseGroups)
{
    baseModels = nullptr;
    baseGroups = nullptr;
    doc.Load(baseShowDir + GetPathSeparator() + XLIGHTS_RGBEFFECTS_FILE);
    if (!doc.IsOk()) return false;

    for (wxXmlNode* m = doc.GetRoot(); m != nullptr; m = m->GetNext()) {
        for (wxXmlNode* mm = m->GetChildren(); mm != nullptr; mm = mm->GetNext()) {
            if (mm->GetName() == "models") baseModels = mm;
            else if (mm->GetName() == "modelGroups") baseGroups = mm;
        }
    }
    return true;
}

bool ModelManager::MergeBaseXml(const std::string& baseShowDir, wxXmlNode* localModelsNode, wxXmlNode* localGroupsNode)
{
    wxXmlDocument baseDoc;
    wxXmlNode* baseModels = nullptr;
    wxXmlNode* baseGroups = nullptr;
    if (!LoadBaseXmlNodes(baseShowDir, baseDoc, baseModels, baseGroups)) return false;

    std::vector<std::string> changedModels;
    std::vector<std::string> changedGroups;
    return MergeBaseIntoCurrentXml(localModelsNode, localGroupsNode,
                                   baseModels, baseGroups,
                                   changedModels, changedGroups);
}

bool ModelManager::MergeFromBase(const std::string& baseShowDir, bool prompt)
{
    bool changed = false;

    wxXmlDocument baseDoc;
    wxXmlNode* baseModels = nullptr;
    wxXmlNode* baseGroups = nullptr;
    if (!LoadBaseXmlNodes(baseShowDir, baseDoc, baseModels, baseGroups)) return false;
    if (baseModels == nullptr) return false;

    // Handle prompt mode: ask user about non-FromBase models that clash with base
    if (prompt) {
        for (wxXmlNode* bm = baseModels->GetChildren(); bm != nullptr; bm = bm->GetNext()) {
            if (bm->GetName() != "model") continue;
            auto name = bm->GetAttribute("name");
            if (name.empty()) continue;
            auto curr = GetModel(name);
            if (curr != nullptr && !curr->IsFromBase()) {
                if (wxMessageBox(wxString::Format("Model %s found that clashes with base show directory. Do you want to take the base show directory version?", name),
                                 "Model clash", wxICON_QUESTION | wxYES_NO, xlights) == wxYES) {
                    curr->SetFromBase(true);
                }
            }
        }
        if (baseGroups != nullptr) {
            for (wxXmlNode* bg = baseGroups->GetChildren(); bg != nullptr; bg = bg->GetNext()) {
                if (bg->GetName() != "modelGroup") continue;
                auto name = bg->GetAttribute("name");
                if (name.empty()) continue;
                auto curr = GetModel(name);
                if (curr != nullptr && !curr->IsFromBase()) {
                    if (wxMessageBox(wxString::Format("Model Group %s found that clashes with base show directory. Do you want to take the base show directory version?", name),
                                     "Model group clash", wxICON_QUESTION | wxYES_NO, xlights) == wxYES) {
                        curr->SetFromBase(true);
                    }
                }
            }
        }
    }

    // Serialize all current models to a temporary XML document for comparison
    XmlSerializer serializer;
    wxXmlNode* currentModelsNode = new wxXmlNode(wxXML_ELEMENT_NODE, "models");
    wxXmlNode* currentGroupsNode = new wxXmlNode(wxXML_ELEMENT_NODE, "modelGroups");

    {
        XmlSerializingVisitor visitor{currentModelsNode};
        for (auto m = begin(); m != end(); ++m) {
            Model* model = m->second;
            if (model->GetDisplayAs() != "ModelGroup") {
                model->Accept(visitor);
            }
        }
    }
    {
        XmlSerializingVisitor visitor{currentGroupsNode};
        for (auto m = begin(); m != end(); ++m) {
            Model* model = m->second;
            if (model->GetDisplayAs() == "ModelGroup") {
                model->Accept(visitor);
            }
        }
    }

    // Run the shared merge
    std::vector<std::string> changedModels;
    std::vector<std::string> changedGroups;
    changed = MergeBaseIntoCurrentXml(currentModelsNode, currentGroupsNode,
                                       baseModels, baseGroups,
                                       changedModels, changedGroups);

    // Apply changes: replace changed models with new ones created from the updated XML
    for (const auto& name : changedModels) {
        wxXmlNode* updatedNode = FindChildByNameAttr(currentModelsNode, "model", name);
        if (updatedNode != nullptr) {
            wxXmlNode* copy = new wxXmlNode(*updatedNode);
            auto curr = GetModel(name);
            if (curr != nullptr) {
                Model* newm = CreateModel(copy, previewWidth, previewHeight);
                ReplaceModel(name, newm);
            } else {
                createAndAddModel(copy, previewWidth, previewHeight);
            }
        }
    }
    for (const auto& name : changedGroups) {
        wxXmlNode* updatedNode = FindChildByNameAttr(currentGroupsNode, "modelGroup", name);
        if (updatedNode != nullptr) {
            wxXmlNode* copy = new wxXmlNode(*updatedNode);
            auto curr = GetModel(name);
            if (curr != nullptr) {
                Model* newm = CreateModel(copy, previewWidth, previewHeight);
                ReplaceModel(name, newm);
            } else {
                createAndAddModel(copy, previewWidth, previewHeight);
            }
        }
    }

    if (changed) {
        RecalcStartChannels();
    }

    // Clean up temporary XML nodes
    delete currentModelsNode;
    delete currentGroupsNode;

    return changed;
}

bool ModelManager::Delete(const std::string& name)
{
    // some layouts end up with illegal names
    std::string mn = Model::SafeModelName(name);

    if (xlights->CurrentSeqXmlFile != nullptr) {
        Element* elem_to_delete = xlights->GetSequenceElements().GetElement(mn);
        if (elem_to_delete != nullptr) {
            // does model have any effects on it
            bool effects_exist = false;
            for (size_t i = 0; i < elem_to_delete->GetEffectLayerCount() && !effects_exist; ++i) {
                auto layer = elem_to_delete->GetEffectLayer(i);
                if (layer->GetEffectCount() > 0) {
                    effects_exist = true;
                }
            }

            if (effects_exist) {
                if (wxMessageBox("Model '" + name + "' exists in the currently open sequence and has effects on it. Delete all effects and layers on this model?", "Confirm Delete?", wxICON_QUESTION | wxYES_NO) != wxYES)
                    return false;
            }

            // Delete the model from the sequencer grid and views
            xlights->GetSequenceElements().DeleteElement(mn);
        }
    }

    // now delete the model
    for (auto it = models.begin(); it != models.end(); ++it) {
        if (it->first == mn) {
            Model* model = it->second;

            if (model != nullptr) {
                for (auto& it2 : models) {
                    if (it2.second->GetDisplayAs() == "ModelGroup") {
                        ModelGroup* group = (ModelGroup*)it2.second;
                        group->ModelRemoved(mn);
                    }
                }
                models.erase(it);
                ResetModelGroups();

                // If models are chained to us then make their start channel ... our start channel
                std::string chainedtous = wxString::Format(">%s:1", model->GetName()).ToStdString();
                for (auto it3 : models) {
                    if (it3.second->ModelStartChannel == chainedtous) {
                        it3.second->SetStartChannel(model->ModelStartChannel);
                    }
                }

                delete model;
                xlights->UnsavedRgbEffectsChanges = true;
                return true;
            }
        }
    }
    return false;
}

std::map<std::string, Model*>::const_iterator ModelManager::begin() const
{
    return models.begin();
}

std::map<std::string, Model*>::const_iterator ModelManager::end() const
{
    return models.end();
}

unsigned int ModelManager::size() const
{
    return models.size();
}

bool ModelManager::IsModelShadowing(const Model* m) const
{
    for (const auto& it : models) {
        if (it.second->GetShadowModelFor() == m->GetName()) {
            return true;
        }
    }
    return false;
}

std::list<std::string> ModelManager::GetModelsShadowing(const Model* m) const
{
    std::list<std::string> res;
    for (const auto& it : models) {
        if (it.second->GetShadowModelFor() == m->GetName()) {
            res.push_back(it.first);
        }
    }
    return res;
}
